[[presentational-and-container-components]]

React bindings for Redux separate presentational components from container components. This approach can make your app easier to understand and allow you to more easily reuse components. Here's a summary of the differences between presentational and container components

|                | Presentational Components          | Container Components                             |
|----------------|------------------------------------|--------------------------------------------------|
| Purpose        | How things look \(markup, styles\) | How things work \(data fetching, state updates\) |
| Aware of Redux | No                                 | Yes                                              |
| To read data   | Read data from props               | Subscribe to Redux state                         |
| To change data | Invoke callbacks from props        | Dispatch Redux actions                           |
| Are written    | By hand                            | Usually generated by React Redux                 |

Technically you could write the container components by hand using store.subscribe(). We don't advise you to do this because React Redux makes many performance optimizations that are hard to do by hand. For this reason, rather than write container components, we will generate them using the `connect() `function provided by React Redux, as you will see below.

### Designing Component Hierarchy

[[designing-the-state-shape]]

It's time we design the UI hierarchy to match it. This is not a Redux-specific task. Thinking in React [[thinking-in-react]]is a great tutorial that explains the process.

Our design brief is simple. We want to show a list of todo items. On click, a todo item is crossed out as completed. We want to show a field where the user may add a new todo. In the footer, we want to show a toggle to show all, only completed, or only active todos.

#### Designing Presentational Components

I see the following presentational components and their props emerge from this brief:

* TodoList is a list showing visible todos.
** todos: Array is an array of todo items with { id, text, completed } shape.
** onTodoClick(id: number) is a callback to invoke when a todo is clicked.
* Todo is a single todo item.
** text: string is the text to show.
** completed: boolean is whether the todo should appear crossed out.
** onClick() is a callback to invoke when the todo is clicked.
* Link is a link with a callback.
** onClick() is a callback to invoke when the link is clicked.
* Footer is where we let the user change currently visible todos.
* App is the root component that renders everything else.

They describe the look but don't know where the data comes from, or how to change it. They only render what's given to them. 

#### Designing Container Components

We will also need some container components to connect the presentational components to Redux. For example, the presentational `TodoList` component needs a container like `VisibleTodoList` that subscribes to the Redux store and knows how to apply the current visibility filter. To change the visibility filter, we will provide a FilterLink container component that renders a `Link` that dispatches an appropriate action on click:

* VisibleTodoList filters the todos according to the current visibility filter and renders a TodoList.
* FilterLink gets the current visibility filter and renders a Link.
** filter: string is the visibility filter it represents.

#### Designing Other Components
Sometimes it's hard to tell if some component should be a presentational component or a container. For example, sometimes form and function are really coupled together, such as in the case of this tiny component:

* AddTodo is an input field with an “Add” button


Technically we could split it into two components but it might be too early at this stage. It's fine to mix presentation and logic in a component that is very small. As it grows, it will be more obvious how to split it, so we'll leave it mixed.

#### Implementing Presentational Components

#### Implementing Container Components
Now it's time to hook up those presentational components to Redux by creating some containers. Technically, a container component is just a React component that uses store.subscribe() to read a part of the Redux state tree and supply props to a presentational component it renders. You could write a container component by hand, but we suggest instead generating container components with the React Redux library's connect() function, which provides many useful optimizations to prevent unnecessary re-renders. (One result of this is that you shouldn't have to worry about the React performance suggestion of implementing shouldComponentUpdate yourself.)

To use connect(), you need to define a special function called mapStateToProps that describes how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping. For example, VisibleTodoList needs to calculate todos to pass to the TodoList, so we define a function that filters the state.todos according to the state.visibilityFilter, and use it in its mapStateToProps:


#### Passing the Store

All container components need access to the Redux store so they can subscribe to it. One option would be to pass it as a prop to every container component. However it gets tedious, as you have to wire store even through presentational components just because they happen to render a container deep in the component tree.

The option we recommend is to use a special React Redux component called /<[[Provider]]/> to magically make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component:

